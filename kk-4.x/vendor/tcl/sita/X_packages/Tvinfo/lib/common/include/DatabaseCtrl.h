#ifndef DATABASE_CTRL_H#define DATABASE_CTRL_H#include <utils/Log.h>#include <pthread.h>#include <stdio.h>#include<stdlib.h>#include<sys/stat.h>#include<fcntl.h>#include <string.h>#include <errno.h>#include <sys/time.h>#include "sqlite3.h"#include "Common.h"#include "Types.h"class SQL_Check{public:	explicit SQL_Check(const char *dbpath, sqlite3** ppdb,sqlite3_stmt **stmt,pthread_mutex_t *pmut = NULL)	{		if(DEBUG) ALOGD("SQL_Check:%s\n", dbpath);		int rc;		m_mutScopeLock = pmut;		m_ppdb=ppdb;		m_stmt = stmt;		if(m_mutScopeLock != NULL)		{			if(DEBUG) ALOGD("SQL_Check:m_mutScopeLock != NULL\n");			PTH_RET_CHK(pthread_mutex_lock(m_mutScopeLock));		}		rc = sqlite3_open_v2(dbpath, m_ppdb, SQLITE_OPEN_READWRITE|SQLITE_OPEN_FULLMUTEX|SQLITE_OPEN_SHAREDCACHE, NULL);		sqlite3_exec(*m_ppdb, "PRAGMA journal_mode = TRUNCATE;", NULL, NULL, NULL);		if(rc)		{			if(DEBUG) ALOGD("SQL_Check: Can't open database:%s\n", sqlite3_errmsg(*m_ppdb));			sqlite3_close(*m_ppdb);			recoveryDBFile(dbpath);		}		else		{			int ColNum;			if(strcmp(dbpath,SQL_DB_TCL_DEVICEINFO_PATH)==0)			{				sqlite3_prepare_v2(*m_ppdb, CHECK_TABLE_DB_DEVICEINFO, strlen(CHECK_TABLE_DB_DEVICEINFO), m_stmt, NULL);			}			ColNum = sqlite3_column_count(*m_stmt);			if(ColNum == 0)			{				if(DEBUG) ALOGD("SQL_Check: Select table error\n");				recoveryDBFile(dbpath);			}			sqlite3_finalize(*m_stmt);		}				if(chmod(dbpath,SQL_DB_PERMISSION) < 0) {			if(DEBUG) ALOGD("Unable to chmod %s: %s\n", dbpath, strerror(errno));		}	};		~SQL_Check(void)	{		if(DEBUG) ALOGD("Call func:%s\n", __PRETTY_FUNCTION__);		int rc = sqlite3_close(*m_ppdb);		if(rc != SQLITE_OK)		{			if(DEBUG) ALOGD("Can't close database, error code:%d\n", rc);		}		if(m_mutScopeLock != NULL)		{			PTH_RET_CHK(pthread_mutex_unlock(m_mutScopeLock));		}		m_ppdb = NULL;	};	protected:    sqlite3 ** m_ppdb;    sqlite3_stmt ** m_stmt;    pthread_mutex_t *m_mutScopeLock;	void copyFile(const char * srcfile,const char *desfile)	{		int   in_fd, out_fd, n_chars;		char  buf[BUFFERSIZE];		if ((in_fd=open(srcfile, O_RDONLY)) == -1)		{		    if(DEBUG) ALOGD("Cannot open src file!!!\n");		    ASSERT(0);		}		if ((out_fd=creat(desfile, SQL_DB_PERMISSION)) == -1 )		{		    if(DEBUG) ALOGD( "Cannot creat new file!!!\n");		    ASSERT(0);		}		while ((n_chars = read(in_fd , buf, BUFFERSIZE)) > 0)		{		    if (write(out_fd, buf, n_chars) != n_chars)			{				if(DEBUG) ALOGD("Write error to !!!\n");				ASSERT(0);		    }		}				if ( n_chars == -1 )		{			if(DEBUG) ALOGD("Read error !!!\n");		    ASSERT(0);		}		if ( close(in_fd) == -1 || close(out_fd) == -1 )		{		    if(DEBUG) ALOGD("Error closing src or des files !!!\n");		    ASSERT(0);		}		if(chmod(desfile,SQL_DB_PERMISSION) < 0) {			if(DEBUG) ALOGD("Unable to chmod %s: %s\n", desfile, strerror(errno));		}	}	void recoveryDBFile(const char * dbFile)	{		if(strcmp(dbFile,SQL_DB_TCL_DEVICEINFO_PATH)==0)		{			copyFile(SQL_DB_TCL_DEVICEINFO_BACKUP_PATH,SQL_DB_TCL_DEVICEINFO_PATH);		}		if(DEBUG) ALOGD("Recovery %s OK\n",dbFile);	}};class SQL_Connect{public:	explicit SQL_Connect(const char *dbpath, sqlite3** ppdb, pthread_mutex_t *pmut = NULL)	{		int rc;		m_ppdb = ppdb;		m_mutScopeLock = pmut;		if(m_mutScopeLock != NULL)		{			PTH_RET_CHK(pthread_mutex_lock(m_mutScopeLock));		}		rc = sqlite3_open_v2(dbpath, m_ppdb, SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE|SQLITE_OPEN_FULLMUTEX|SQLITE_OPEN_SHAREDCACHE, NULL);		sqlite3_exec(*m_ppdb, "PRAGMA journal_mode = TRUNCATE;", NULL, NULL, NULL);		if(rc)		{			if(DEBUG) ALOGD("Can't open database:%s\n", sqlite3_errmsg(*m_ppdb));			sqlite3_close(*m_ppdb);			ASSERT(0);		}	};		~SQL_Connect(void)	{		if(DEBUG) ALOGD("Call func:%s\n", __PRETTY_FUNCTION__);		int rc = sqlite3_close(*m_ppdb);		if(rc != SQLITE_OK)		{			if(DEBUG) ALOGD("Can't close database, error code:%d\n", rc);		}		if(m_mutScopeLock != NULL)		{			PTH_RET_CHK(pthread_mutex_unlock(m_mutScopeLock));		}		m_ppdb = NULL;	};protected:    sqlite3 ** m_ppdb;    pthread_mutex_t *m_mutScopeLock;};class SQL_Transaction{public:	explicit SQL_Transaction(sqlite3 *db)	{		if(db == NULL)		{			return;		}				pdb = db;		rc = sqlite3_exec(pdb,"BEGIN EXCLUSIVE TRANSACTION;",0,0,&zErrMsg);		if( rc != SQLITE_OK)		{			if(DEBUG) ALOGD("SQL Transaction error:%s\n", zErrMsg);			sqlite3_free(zErrMsg);		}	};		~SQL_Transaction(void)	{		if(pdb == NULL)		{			return;		}		rc=sqlite3_exec(pdb,"COMMIT TRANSACTION;",0,0,&zErrMsg);		if( rc != SQLITE_OK)		{			if(DEBUG) ALOGD("SQL Transaction end error:%s\n", zErrMsg);			sqlite3_free(zErrMsg);		}	};private:    sqlite3 * pdb;    int rc;    char *zErrMsg;};class SQL_LookupPre{public:	explicit SQL_LookupPre(sqlite3 *db, sqlite3_stmt **stmt, const char *table, char *sql, int &ColNum, char * Condition = NULL)	{		m_stmt = stmt;		memset(sql, 0, QUERY_STRING_LENGTH);		if(Condition == NULL)		{			snprintf(sql, QUERY_STRING_LENGTH, "select * from %s;", table);		}		else		{			snprintf(sql, QUERY_STRING_LENGTH, "select * from %s where %s;", table, Condition);		}		if(DEBUG) ALOGD("MSG_SQL_INFO:%s\n",sql);		sqlite3_prepare_v2(db, sql, strlen(sql), m_stmt, NULL);		ColNum = sqlite3_column_count(*m_stmt);		if(DEBUG) ALOGD("%s(ColNum=%d)\n", table, ColNum);		if(ColNum == 0)		{			if(DEBUG) ALOGD("select table error!!\n");		}	};	~SQL_LookupPre(void)	{		sqlite3_finalize(*m_stmt);	};protected:    sqlite3_stmt ** m_stmt;};int SQL_Step(sqlite3_stmt * pstmt);BOOL SQL_SetU32(sqlite3* db, const char *Table, const char * Title, const char * Condition, U32 Value);BOOL SQL_SetText(sqlite3* db, const char *Table, const char * Title, const char * Condition, char * Text);BOOL SQL_SetBlob(sqlite3* db, const char *Table, const char * Title, const char * Condition, U8 * BlobArray, U16 u16Size);BOOL SQL_SetArray(sqlite3* db, const char *Table, const char * Title, const char * Condition, void * pArray, U16 u16Size, U8 ArrayType);U32 SQL_GetU32(sqlite3_stmt * stmt, const char * Title);const U8 * SQL_GetText(sqlite3_stmt * stmt, const char * Title);U8 * SQL_GetBlob(sqlite3_stmt * stmt, const char * Title, U16 u16Size);BOOL SQL_GetArray(sqlite3_stmt * stmt, const char * Title, void * pArray, U16 u16Size, U8 ArrayType);int SQL_GetColumnIndex(sqlite3_stmt * stmt,const char *ColName);#endif