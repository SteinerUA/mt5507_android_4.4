#include "DatabaseCtrl.h"int SQL_Step(sqlite3_stmt * pstmt){    int rc = SQLITE_ERROR;    rc = sqlite3_step(pstmt);    if(rc == SQLITE_DONE)    {        if(DEBUG) ALOGD("SQL_Step End\n");    }    else if(rc == SQLITE_ROW)    {        if(DEBUG) ALOGD("SQL_Step Row\n");    }    else    {        if(DEBUG) ALOGD("SQL_Step Row error:%d\n",rc);        rc = sqlite3_reset(pstmt);    }    return rc;}BOOL SQL_SetU32(sqlite3* db, const char *Table, const char * Title, const char * Condition, U32 Value){    int rc=SQLITE_ERROR;    U8 u8TimeOut = 3;    char *zErrMsg=NULL;    char str_SQL[QUERY_STRING_LENGTH]={0};    snprintf(str_SQL, QUERY_STRING_LENGTH, "UPDATE %s SET %s=%ld WHERE %s;", Table, Title, Value, Condition);    if(DEBUG) ALOGD("MSG_SQL_DBG:%s\n",str_SQL);    do    {        rc = sqlite3_exec(db, str_SQL, NULL, 0, &zErrMsg);        if( rc == SQLITE_OK)        {            break;        }        else        {            if(DEBUG) ALOGD("SQL_SetU32 error:%s ,str_SQL:%s\n", zErrMsg,str_SQL);            if( strstr(zErrMsg, "database is locked") )            {                usleep(50 * 1000);            }            else if( strstr(zErrMsg, "unable to open") )            {                usleep(50 * 1000);            }            u8TimeOut --;			            if(zErrMsg != NULL)            {                sqlite3_free(zErrMsg);                zErrMsg = NULL;            }        }    }while(u8TimeOut);    if(zErrMsg != NULL)    {        sqlite3_free(zErrMsg);    }    if(u8TimeOut == 0)    {        sqlite3_exec(db, "IGNORE;", NULL, 0, NULL);        return FALSE;    }    else    {       return TRUE;    }}BOOL SQL_SetText(sqlite3* db, const char *Table, const char * Title, const char * Condition, char * Text){    int rc=SQLITE_ERROR;    U8 u8TimeOut = 3;    char *zErrMsg=NULL;    char str_SQL[QUERY_STRING_LENGTH]={0};    if(Text == NULL)	{        return FALSE;	}    snprintf(str_SQL, QUERY_STRING_LENGTH, "UPDATE %s SET %s=\"%s\" WHERE %s;", Table, Title, Text, Condition);    if(DEBUG) ALOGD("MSG_SQL_DBG:%s\n",str_SQL);    do    {        rc = sqlite3_exec(db, str_SQL, NULL, 0, &zErrMsg);        if( rc == SQLITE_OK)        {            break;        }        else        {            if(DEBUG) ALOGD("SQL_SetText error:%s\n", zErrMsg);            if( strstr(zErrMsg, "database is locked") )            {                usleep(50 * 1000);            }            else if( strstr(zErrMsg, "unable to open") )            {                usleep(50 * 1000);            }            u8TimeOut --;            if(zErrMsg != NULL)            {                sqlite3_free(zErrMsg);                zErrMsg = NULL;            }        }    }while(u8TimeOut);    if(zErrMsg != NULL)    {        sqlite3_free(zErrMsg);    }    if(u8TimeOut == 0)    {        sqlite3_exec(db, "IGNORE;", NULL, 0, NULL);        return FALSE;    }    else    {       return TRUE;    }}BOOL SQL_SetBlob(sqlite3* db, const char *Table, const char * Title, const char * Condition, U8 * BlobArray, U16 u16Size){    int rc=SQLITE_ERROR;    U8 u8TimeOut = 3;    sqlite3_stmt * pStmt;    char *zErrMsg=NULL;    char str_SQL[QUERY_STRING_LENGTH]={0};    if(BlobArray == NULL)        return FALSE;    snprintf(str_SQL, QUERY_STRING_LENGTH, "UPDATE %s SET %s=? WHERE %s;", Table, Title, Condition);    if(DEBUG) ALOGD("MSG_SQL_DBG:%s\n",str_SQL);    sqlite3_prepare_v2(db, str_SQL, strlen(str_SQL), &pStmt, NULL);    sqlite3_bind_blob( pStmt, 1, (const void *)BlobArray, u16Size, NULL );    do    {        rc = SQL_Step(pStmt);        if( rc == SQLITE_ROW ||rc == SQLITE_DONE )        {            break;        }        else        {            if(DEBUG) ALOGD("SQL_SetU32 error:%s\n", zErrMsg);            if( strstr(zErrMsg, "database is locked") )            {                usleep(500 * 1000);            }            u8TimeOut --;            if(zErrMsg != NULL)            {                sqlite3_free(zErrMsg);                zErrMsg = NULL;            }        }    }while(u8TimeOut);    if(zErrMsg != NULL)    {        sqlite3_free(zErrMsg);    }    sqlite3_reset(pStmt);    sqlite3_finalize(pStmt);    if(u8TimeOut == 0)    {        return FALSE;    }    else    {       return TRUE;    }}BOOL SQL_SetArray(sqlite3* db, const char *Table, const char * Title, const char * Condition, void * pArray, U16 u16Size, U8 ArrayType){    int rc = SQLITE_ERROR;    U8 u8TimeOut = 4;    char *zErrMsg=NULL;    char str_SQL[QUERY_STRING_LENGTH*2]={0};    char str_Val[64]={0};    char str_Tail[QUERY_STRING_LENGTH]={0};    if(pArray == NULL)        return FALSE;    snprintf(str_SQL, QUERY_STRING_LENGTH*2, "UPDATE %s SET %s=\"", Table, Title);    snprintf(str_Tail, QUERY_STRING_LENGTH, "\" WHERE %s;", Condition);    int index = 0;    switch(ArrayType)    {        case U8_ARRAY_TYPE:        {            U8 * pdata = (U8 *)pArray;            do            {                snprintf(str_Val, 64, "0x%x,", *((U8 *)pdata));                strcat(str_SQL, str_Val);                pdata += 1;                index ++;            }while(( index < u16Size )&& (strlen(str_SQL) + strlen(str_Tail) < QUERY_STRING_LENGTH*2));            snprintf(str_Val, 64, "\"");            strcat(str_SQL, str_Val);        }        break;		        case U16_ARRAY_TYPE:        {            U16 * pdata = (U16 *)pArray;            do            {                snprintf(str_Val, 64, "0x%x,", *((U16 *)pdata));                strcat(str_SQL, str_Val);                pdata += 1;                index ++;            }while(( index < u16Size )&& (strlen(str_SQL) + strlen(str_Tail) < QUERY_STRING_LENGTH*2));            snprintf(str_Val, 64, "\"");            strcat(str_SQL, str_Val);        }        break;		        case U32_ARRAY_TYPE:        {            U32 * pdata = (U32 *)pArray;            do            {                snprintf(str_Val, 64, "0x%lx,", *((U32 *)pdata));                strcat(str_SQL, str_Val);                pdata += 1;                index ++;            }while(( index < u16Size )&& (strlen(str_SQL) + strlen(str_Tail) < QUERY_STRING_LENGTH*2));            snprintf(str_Val, 64, "\"");            strcat(str_SQL, str_Val);        }        break;		        default:        {            if(DEBUG) ALOGD("SQL_SetArray error!Not supported type !\n");            ASSERT(0);            return FALSE;            break;        }    }    if(DEBUG) ALOGD("MSG_SQL_DBG:%s\n",str_SQL);    do    {        rc = sqlite3_exec(db, str_SQL, NULL, 0, &zErrMsg);        if( rc == SQLITE_OK)        {            break;        }        else        {            if(DEBUG) ALOGD("SQL_SetText error:%s\n", zErrMsg);            if( strstr(zErrMsg, "database is locked"))            {                usleep(50 * 1000);            }            else if( strstr(zErrMsg, "unable to open"))            {                usleep(50 * 1000);            }            u8TimeOut --;        }    }while(u8TimeOut);    if(zErrMsg != NULL)    {        sqlite3_free(zErrMsg);        zErrMsg = NULL;    }    if(u8TimeOut == 0)    {        sqlite3_exec(db, "IGNORE;", NULL, 0, NULL);        return FALSE;    }    else    {       return TRUE;    }}U32 SQL_GetU32(sqlite3_stmt * stmt, const char * Title){    U32  RetVal = 0;    int ColIndex = SQL_GetColumnIndex(stmt, (const char *)Title);    if(ColIndex == -1)    {        if(DEBUG) ALOGD("SQL_GetU32 error!No such Column %s\n",Title);        ASSERT(0);        return 0;    }    RetVal = sqlite3_column_int64(stmt, ColIndex);    return RetVal;}const U8 * SQL_GetText(sqlite3_stmt * stmt, const char * Title){    int ColIndex = SQL_GetColumnIndex(stmt, (const char *)Title);    if(ColIndex == -1)    {        if(DEBUG) ALOGD("SQL_GetText error!No such Column %s\n",Title);        ASSERT(0);        return 0;    }    return (sqlite3_column_text(stmt, ColIndex));}U8 * SQL_GetBlob(sqlite3_stmt * stmt, const char * Title, U16 u16Size){    int ColIndex = SQL_GetColumnIndex(stmt, (const char *)Title);    if(ColIndex == -1)    {        if(DEBUG) ALOGD("SQL_GetBlob error!No such Column %s\n",Title);        ASSERT(0);        return 0;    }    if(sqlite3_column_bytes(stmt, ColIndex) < u16Size)    {        if(DEBUG) ALOGD("SQL_GetBlob error!Column %s blob size<%d\n",Title, u16Size);        return NULL;    }    return (U8 *)(sqlite3_column_blob(stmt, ColIndex));}BOOL SQL_GetArray(sqlite3_stmt * stmt, const char * Title, void * pArray, U16 u16Size, U8 ArrayType){    char str_Text[QUERY_STRING_LENGTH*2] = {0};    int ColIndex = SQL_GetColumnIndex(stmt, (const char *)Title);    if(ColIndex == -1)    {        if(DEBUG) ALOGD("SQL_GetArray error!No such Column %s\n",Title);        ASSERT(0);        return 0;    }    if(pArray == NULL)        return FALSE;    strncpy(str_Text, (char *)sqlite3_column_text(stmt, ColIndex), QUERY_STRING_LENGTH*2);    U32 temp_value = 0;    int temp_Idx = 0;    switch(ArrayType)    {        case U8_ARRAY_TYPE:        {            U8 aU8Data[u16Size];            memset(aU8Data, 0, sizeof(aU8Data));            for(int index=0; ((index+1) < strlen(str_Text)) && (temp_Idx<u16Size); index ++)            {                if((str_Text[index]==',') ||(str_Text[index+1] == '\0'))                {                    aU8Data[temp_Idx] = (U8)temp_value;                    temp_Idx ++;                }                else if(str_Text[index]=='0' && (str_Text[index+1]=='x' ||str_Text[index+1]=='X'))                {                    temp_value = 0;                    index ++;                }                else if((str_Text[index]>='0') && (str_Text[index]<='9'))                {                    temp_value = (temp_value << 4) + (str_Text[index] - '0' );                }                else if((str_Text[index]>='A') && (str_Text[index]<='F'))                {                    temp_value = (temp_value << 4) + (str_Text[index] - 'A' );                }                else if((str_Text[index]>='a') && (str_Text[index]<='f'))                {                    temp_value = (temp_value << 4) + (str_Text[index] - 'a' );                }                else                    index = strlen(str_Text);            }            memcpy((U8 *)pArray, aU8Data, sizeof(aU8Data));        }        break;		        case U16_ARRAY_TYPE:        {            U16 aU16Data[u16Size];            memset(aU16Data, 0, sizeof(aU16Data));            for(int index=0; ((index+1) < strlen(str_Text)) && (temp_Idx<u16Size); index ++)            {                if((str_Text[index]==',') ||(str_Text[index+1] == '\0'))                {                    aU16Data[temp_Idx] = (U16)temp_value;                    temp_Idx ++;                }                else if(str_Text[index]=='0' && (str_Text[index+1]=='x' ||str_Text[index+1]=='X'))                {                    temp_value = 0;                    index ++;                }                else if((str_Text[index]>='0') && (str_Text[index]<='9'))                {                    temp_value = (temp_value << 4) + (str_Text[index] - '0' );                }                else if((str_Text[index]>='A') && (str_Text[index]<='F'))                {                    temp_value = (temp_value << 4) + (str_Text[index] - 'A' );                }                else if((str_Text[index]>='a') && (str_Text[index]<='f'))                {                    temp_value = (temp_value << 4) + (str_Text[index] - 'a' );                }                else                    index = strlen(str_Text);            }            memcpy((U16 *)pArray, aU16Data, sizeof(aU16Data));        }        break;		        case U32_ARRAY_TYPE:        {            U32 aU32Data[u16Size];            memset(aU32Data, 0, sizeof(aU32Data));            for(int index=0; ((index+1) < strlen(str_Text)) && (temp_Idx<u16Size); index ++)            {                if((str_Text[index]==',') ||(str_Text[index+1] == '\0'))                {                    aU32Data[temp_Idx] = (U32)temp_value;                    temp_Idx ++;                }                else if(str_Text[index]=='0' && (str_Text[index+1]=='x' ||str_Text[index+1]=='X'))                {                    temp_value = 0;                    index ++;                }                else if((str_Text[index]>='0') && (str_Text[index]<='9'))                {                    temp_value = (temp_value << 4) + (str_Text[index] - '0' );                }                else if((str_Text[index]>='A') && (str_Text[index]<='F'))                {                    temp_value = (temp_value << 4) + (str_Text[index] - 'A' );                }                else if((str_Text[index]>='a') && (str_Text[index]<='f'))                {                    temp_value = (temp_value << 4) + (str_Text[index] - 'a' );                }                else                    index = strlen(str_Text);            }            memcpy((U32 *)pArray, aU32Data, sizeof(aU32Data));        }        break;		        default:        {            if(DEBUG) ALOGD("SQL_GetArray error!Not supported type !\n");            ASSERT(0);            return FALSE;            break;        }    }    return TRUE;}int SQL_GetColumnIndex(sqlite3_stmt * stmt,const char *ColName){    int Index = 0;    int ColNum = sqlite3_column_count(stmt);    for(Index = 0; Index < ColNum; Index ++)    {        if(strcmp(ColName, sqlite3_column_name(stmt, Index)) == 0)        {            break;        }    }    if(Index >= ColNum)    {        Index = -1;    }    return Index;}